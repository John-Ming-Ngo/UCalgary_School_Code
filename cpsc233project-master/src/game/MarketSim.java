package game;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;

import game.IOStuff.EventManager;
import game.IOStuff.LogManager;
import game.IOStuff.SaveManager;
import game.IOStuff.ScoreManager;
import game.IOStuff.audio.SoundLayer;
import game.IOStuff.audio.SoundException;
import game.investments.PreciousMetal;

/**
 * This class is the main class for the stock simulation
 * 
 * It holds the text based gui and all the logic between the gui screens.
 * 
 * @author Team 13 (John Ngo, Bob Rao, Huidong Lu, Jason De Boer)
 * 
 * @version 0.1 25 Jan 2017
 * 
 * 
 */

public class MarketSim {

	/*
	 * Initialize user interface constants.
	 */
	public static final String PATH = "resources" + File.separator;
	public static final String BACKGROUND_MUSIC = "resources" + File.separator + "soundtracks" + File.separator + "Russian_Empire.mp3";
	private static final String BORDER = "--------------------------------------------------";
	private static final double EVENT_PROBABILITY = 0.05;
	private static final boolean GUI_WRAPPER_ENABLE = true;
	private static final double EVENT_WEIGHT = 0.0;

	/*
	 * Initialize Instance Variables.
	 * 
	 */
	protected Player player1 = null;
	private int intervalLength = 7;// 7 day intervals (weekly)
	private int numberOfTurns = 52;
	private int turn = 0;
	private String startDate;
	private String stockIndex;
	private String stockNameList;
	private boolean optionRandomEvents = false;

	/*
	 * Constructors
	 */

	public MarketSim() {
		this(0, 52, "2010-02-01", "^DJI", new Player());
	}

	public MarketSim(int turn, int numberOfTurns, String startDate, String stockIndex, Player player1) {
		this.turn = turn;
		this.numberOfTurns = numberOfTurns;
		this.startDate = startDate;
		this.stockIndex = stockIndex;
		this.player1 = new Player(player1);
		

	}

	public MarketSim(int turn, int numberOfTurns, String startDate, String stockIndex, Player player1,
			String stockNameList) {
		this(turn, numberOfTurns, startDate, stockIndex, player1);
		this.stockNameList = stockNameList;
	}

	public MarketSim(MarketSim stocksimToCopy) {
		this(stocksimToCopy.turn, stocksimToCopy.numberOfTurns, stocksimToCopy.startDate, stocksimToCopy.stockIndex,
				stocksimToCopy.player1, stocksimToCopy.stockNameList);
	}
	
	
	
	/**
	 * addStock() - Add Stock to List
	 * 
	 * @throws IOException
	 * 
	 */
	public void addStock() throws IOException {

		Scanner input = new Scanner(System.in);
		System.out.println("What is the stock symbol?");

		String symbol = input.next();

		player1.addStock(symbol, startDate, intervalLength, numberOfTurns, turn);
		input.close();

	}

	/**
	 * increaseTurn - increase the turn number
	 * 
	 * @return any message generated by the event
	 * @throws IOException
	 * 
	 */
	public String[] advanceTurn() throws IOException {
		String[] eventMessage = null;

		// save the state and advance turn
		saveGame();
		turn++;

		// process random events
		if (isOptionRandomEvents())
			eventMessage = generateRandomEvent(EVENT_WEIGHT);
		if (isSimulationComplete()) {
			ScoreManager scoremanager = new ScoreManager(player1);
			scoremanager.save();
		}

		player1.updatePortfolio(turn);
		return eventMessage;
	}

	/**
	 * buyStock() - Buy Stocks
	 * 
	 * 
	 */
	public void buyInvestment() {
		int investmentIndex = MarketSimUtils.getValidInt("\nWhich Investment would you like to buy?");
		int quantity = MarketSimUtils.getValidInt("How much would you like to buy?");
		player1.buyInvestment(investmentIndex, quantity);
	}

	/**
	 * This method runs and executes a random event, making all the necessary
	 * adjustments corresponding to this event. Note that it requires that an
	 * EventManager been initialized.
	 * 
	 * @param eventRarity
	 *            A double corresponding to how rare the event must be in order
	 *            to be selected as the random event. The larger the number,
	 *            more common the event, and vice versa. Small numbers only
	 *            allow for the possibility of rare events being selected; they
	 *            do not guarantee rare events being selected.
	 */
	public String[] generateRandomEvent(double eventRarity) throws IOException {

		String[] eventInfo = null;

		// random event only triggers based on probability
		if (Math.random() < EVENT_PROBABILITY) {
			ArrayList<String> eventData = null;
			boolean eventSelected = false;
			EventManager randomEventGenerator = new EventManager();
			// Select a random event with likelihood of happening above the
			// specified event rarity.
			while (!eventSelected) {
				eventData = randomEventGenerator.randomEvent();
				if (Double.parseDouble(eventData.get(2)) >= eventRarity) {
					eventSelected = true;
				}
			}
			// Determine the type of event it is and act upon it.
			switch (eventData.get(3)) {
			case "Money %":
				player1.percentMoneyChange(Double.parseDouble(eventData.get(4)));
				break;
			case "Stock %":
				player1.percentStockChange(Double.parseDouble(eventData.get(4)));
				break;
			case "Money #":
				player1.absoluteMoneyChange(Double.parseDouble(eventData.get(4)));
				break;
			case "stock #":
				player1.absoluteStockChange(Double.parseDouble(eventData.get(4)));
				break;
			default:
				System.out.println("Event cannot be comprehended!");
			}
			// Print out the name of the event and what it did to the player.
			eventInfo = new String[2];
			eventInfo[0] = eventData.get(0);
			eventInfo[1] = MarketSimUtils.wrapString(eventData.get(1), 30);
		}
		return eventInfo;
	}

	/**
	 * @return the interval length
	 */
	public int getIntervalLength() {
		return intervalLength;

	}

	/**
	 * Returns a list of the types of precious metals
	 * 
	 * @return list of the types of Precious Metals
	 */
	public ArrayList<String> getMetalIndexList() {
		ArrayList<String> list = new ArrayList<String>();

		for (PreciousMetal.Metal value : PreciousMetal.Metal.values()) {
			list.add(value.toString());
		}

		return list;
	}

	/**
	 * getNumberOfTurns - returns the number of turns
	 * 
	 * @return turn
	 * 
	 */
	public int getNumberOfTurns() {
		return numberOfTurns;
	}

	/**
	 * Get the instance of the player note: the privacy leak is intentional in
	 * this case as access is needed to the player object in order to add to
	 * investment lists
	 * 
	 * @return the instance of the player
	 */
	public Player getPlayer() {
		return player1;
	}

	/**
	 * Returns the Player Scores
	 * 
	 * @return PlayerScores
	 * @throws IOException
	 */
	public ArrayList<String> getScores() throws IOException {
		ScoreManager score = new ScoreManager();
		ArrayList<String> scoreData = score.getScoreData();
		return scoreData;
	}

	/**
	 * Returns the start date for the simulation.
	 * 
	 * @return the startDate
	 */
	public String getStartDate() {
		return startDate;
	}

	/**
	 * Return the stock index
	 * 
	 * @return the stock index
	 */
	public String getStockIndex() {
		return stockIndex;
	}

	/**
	 * getStockIndexList() Returns an ArrayList of stock symbols from a file
	 * 
	 * @return an ArrayList of stocklist symbols
	 * @throws FileNotFoundException
	 * 
	 */
	public ArrayList<String> getStockIndexList() throws FileNotFoundException {
		ArrayList<String> list = new ArrayList<String>();

		String filename = PATH + getStockNameList();

		Scanner inputStream = null;
		File fileObject = new File(filename);

		// Reads the list into a string if file exists
		if (fileObject.exists()) {
			try {
				inputStream = new Scanner(fileObject);
			} catch (FileNotFoundException fnfe) {
				throw new FileNotFoundException(filename + "is not found");

			}

			// parse the csv file line by line
			// takes the first
			while (inputStream.hasNextLine()) {
				String line = inputStream.nextLine();
				String[] temp = line.split(",");
				// old required for google list.add(temp[0] + ":" + temp[1] +
				// "-" + temp[2]);
				// new parsing removes the first part of the index for yahoo
				list.add(temp[1] + "-" + temp[2]);
			}
			inputStream.close();
		}

		return list;
	}

	/**
	 * Return the stock name list
	 * 
	 * Returns the filename of the list of stocks to use
	 * 
	 * @return stockNameList
	 */
	public String getStockNameList() {
		return stockNameList;
	}

	/**
	 * getTurn() - returns the turn number
	 * 
	 * @return turn
	 * 
	 */
	public int getTurn() {
		return turn;
	}

	/**
	 * Returns the true if random events are enabled
	 * 
	 * @return the optionRandomEvents
	 */
	public boolean isOptionRandomEvents() {
		return optionRandomEvents;
	}

	/**
	 * This method determines if the simulation is over.
	 * 
	 * @return true if simulation is complete or false if not
	 * 
	 */
	public boolean isSimulationComplete() {
		return (turn > numberOfTurns);
	}

	/**
	 * This class loads all the relevant state variables from a text file with
	 * name corresponding to the input playerName. It makes use of the
	 * SaveManager class, one of the classes in IOStuff.
	 * 
	 * @param playerName
	 *            A Strong corresponding to the username of the player.
	 */
	public void loadGame(String playerName) throws IOException {
		SaveManager fileManager = new SaveManager();
		fileManager.loadState(playerName, this);
		player1 = new Player(fileManager.getPlayer());
	}

	/**
	 * This method can load a game up from a given save file. Meant for the text
	 * based GUI.
	 * 
	 * @throws IOException
	 */
	public void loadSimulation() throws IOException {
		SaveManager fileManager = new SaveManager();
		fileManager.loadState(MarketSimUtils.getValidInput("Username: ", "[A-Za-z0-9]*"), this);
		player1 = new Player(fileManager.getPlayer());
		mainSimulationMenu(numberOfTurns);
	}

	/**
	 * Main Menu - The start menu
	 * @deprecated Used only in the old text-based gui version of the program.
	 * @throws IOException
	 * 
	 */
	public void mainMenu() throws IOException {
		boolean endGame = false;
		while (endGame == false) {
			// display user menu
			System.out.println("\n\n\n\n\nMain Menu");
			System.out.println(BORDER);
			System.out.println("[N]ew Simulation");
			System.out.println("[L]oad Simulation");
			System.out.println("[H]igh Scores.");
			System.out.println("[Q]uit\n");
			System.out.println(BORDER);

			String menuSelection = MarketSimUtils.getValidInput("<Please make a selection>", "[NnLlHhQq]");
			menuSelection = menuSelection.toLowerCase();

			switch (menuSelection) {

			// new simulation
			case "n":
				setupNewSimulation();
				break;
			// load simulation
			case "l":
				loadSimulation();
				break;
			// View high scores.
			case "h":
				// scoreMenu();
				// Quit
			case "q":
				endGame = true;
				break;
			default:
				System.out.print("BUG DETECTED. SOMETHING GOT PAST THE INPUT CHECKER.");

			}// switch
		} // while
	}

	/**
	 * The main simulation menu
	 * 
	 * @param numberOfTurns
	 *            number of turns to simulate
	 * @throws IOException
	 */
	public void mainSimulationMenu(int numberOfTurns) throws IOException {

		boolean isQuit = false;

		// run menu simulation loop
		while (!isQuit && turn < numberOfTurns) {
			printStatus();
			System.out.println(BORDER);
			System.out.println("Menu");
			System.out.println("[A]dd Stock to List");
			System.out.println("[C]heck Stocks.");
			System.out.println("[B]uy Stock.");
			System.out.println("[S]ell Stock.");
			System.out.println("[N]ext week.");
			System.out.println("[Q]uit.");
			System.out.println(BORDER);
			String menuSelection = MarketSimUtils.getValidInput("\nPlease make a selection> ", "[ACBSQNacbsqn]");
			menuSelection = menuSelection.toLowerCase();

			// switch (menuSelection){
			char selection = menuSelection.charAt(0);
			switch (selection) {

			// new simulation
			case 'a':
				System.out.println("Add Stock to List");
				addStock();
				break;
			case 'c':
				System.out.println("Check Stock - Not Implemented yet");
				break;
			case 'b':
				System.out.println("Buy Stock");
				buyInvestment();
				break;
			case 's':
				System.out.println("Sell Stock.");
				sellInvestment();
				break;
			case 'n':
				turn++;
				player1.updatePortfolio(turn);
				progressReport();
				break;
			// Quit
			case 'q':
				isQuit = true;
				break;

			default:
				System.out.print("Should never see this message");

			}// switch
		} // while
	}// runSimulation

	/**
	 * printStatus() - Display user status
	 * 
	 * @return status output
	 * 
	 */
	public String printStatus() {
		String outputString = "";

		outputString = "Turn:" + turn;
		outputString += "\n" + BORDER + "\n";
		outputString += String.format("%15s $%10.2f\n", "Bank Balance:", player1.getCurrentMoney());
		outputString += String.format("%15s $%10.2f\n", "Net Worth:", player1.getNetWorth());

		outputString += "\nStock List:\n";
		outputString += player1.getInvestmentListReport(); // prints out players
															// portfolio
		if (!GUI_WRAPPER_ENABLE)
			System.out.println(outputString);

		return outputString;
	}// printStatus

	public String progressReport() {
		String output = BORDER + "\nProgress Report\n" + BORDER + "\n";
		output += "Money gained/lost from week " + (turn - 1) + ": $\n";
		output += "Monetary percentage change from last turn: %\n";
		output += "Monetary percentage change since week 1: %\n";
		output += "Stocks gained/lost from last turn: \n";
		output += "Stocks gained/lost since week 1: \n";

		if (!GUI_WRAPPER_ENABLE)
			System.out.println(output);

		return output;

	}

	/**
	 * This method takes the state variables in this game and saves them to a
	 * text file. It makes use of the SaveManager class, one of the classes in
	 * IOStuff.
	 * 
	 */
	public void saveGame() throws IOException {
		SaveManager fileManager = new SaveManager(player1, new MarketSim(this));
		fileManager.save();
	}

	/**
	 * sellStock() - Buy Stocks
	 * 
	 */
	public void sellInvestment() {
		int investmentIndex = MarketSimUtils.getValidInt("\nWhich Investment would you like to sell?");
		int stockQty = MarketSimUtils.getValidInt("How much would you like to sell?");
		player1.sellInvestment(investmentIndex, stockQty);
	}

	/**
	 * Sets the current turn of the simulation
	 * 
	 * @param turn
	 *            to set to
	 */
	public void setCurrentTurn(int turn) {
		this.turn = turn;

	}

	/**
	 * setTurns() Sets the number of game turns
	 * 
	 * @param date The date to start the simulation
	 * 
	 */
	public void setDate(String date) {
		startDate = date;
	}

	public void setIndex(String stockIndex) {
		this.stockIndex = stockIndex;
	}

	/**
	 * setIntervalLength() Sets the number of game turns
	 * 
	 * @param days length of each interval
	 * 
	 */
	public void setIntervalLength(int days) {
		intervalLength = days;
	}

	/**
	 * setTurns() Sets the number of game turns
	 * 
	 * @param turns
	 * 
	 */
	public void setNumberOfTurns(int turns) {
		numberOfTurns = turns;
	}

	/**
	 * @param optionRandomEvents
	 *            the optionRandomEvents to set
	 */
	public void setOptionRandomEvents(boolean optionRandomEvents) {
		this.optionRandomEvents = optionRandomEvents;
	}

	/**
	 * Sets the filename of the list of stocks to use
	 * 
	 * @param name
	 *            filename of the list of stocks to use
	 */
	public void setStockNameList(String name) {
		stockNameList = name;
	}

	/**
	 * setupNewSimulation - Start a new simulation
	 * @throws IOException
	 * 
	 */
	public void setupNewSimulation() throws IOException {

		player1.setUserName(MarketSimUtils.getValidInput("Name:", "[A-Za-z0-9]*"));

		String startMoney = (MarketSimUtils.getValidInput("Please enter starting money:", "(\\d*\\.\\d*|\\d*)"));
		player1.setCurrentMoney(Double.parseDouble(startMoney));

		numberOfTurns = MarketSimUtils.getValidInt("\n\nHow many weeks to play:>", 0, 2000);
		startDate = MarketSimUtils.getValidInput("Start Date yyyy-mm-dd:",
				"^(19|20)\\d\\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$");

		// TODO: validate date to a weekday and non holiday -here or in stock

		// start the simulation
		mainSimulationMenu(numberOfTurns);
	}

	/**
	 * Main method - Runs the simulation
	 * 
	 * @param args
	 *            - command line arguments
	 * @throws IOException
	 * 
	 */
	public static void main(String[] args) throws IOException {
		MarketSim simulation = new MarketSim();
		if (GUI_WRAPPER_ENABLE) {
			SimulationController simGui = new SimulationController();
			simGui.init();

		} else {
			simulation.mainMenu();
		}
	}
}